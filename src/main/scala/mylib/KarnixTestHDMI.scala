package mylib 

import spinal.core._
import spinal.lib._
import mylib._
import spinal.lib.blackbox.lattice.ecp5._ // for EHXPLLL 

case class KarnixTestHDMITopLevel(
        horiz_back_porch: Int = 48,
        horiz_active: Int = 640,
        horiz_front_porch: Int = 16,
        horiz_sync: Int = 96,
        vert_back_porch: Int = 33,
        vert_active: Int = 480,
        vert_front_porch: Int = 10,
        vert_sync: Int = 2
  ) extends Component{

    val io = new Bundle {
        val clk25 = in Bool()
        val hdmi = master(HDMIInterface())
    }

    val pixclk_in = Bool() /* Artificially synthesized clock */
    val pixclk = Bool() /* Artificially synthesized clock globally routed (ECP5 specific) */
    val pixclk_x10 = Bool() /* x10 multiplied clock */  

    /* Route artificial TMDS clock using global lines, i.e. DCCA (ECP5 specific) */
    val dcca = new DCCA()
    dcca.CLKI := pixclk_in
    dcca.CE := True
    pixclk := dcca.CLKO

    /* Use ECP5 hard PLL block to multiply board provided 25.0 MHz to get 250.0 MHz for TMDS encoder.
     * All PLL parameters are generated by ecppll utility.
     */
    val tmds_pll = new EHXPLLL( EHXPLLLConfig(clkiFreq = 25.0 MHz, mDiv = 1, fbDiv = 10, opDiv = 2) )
    tmds_pll.io.CLKI := io.clk25
    tmds_pll.io.CLKFB := tmds_pll.io.CLKOP
    tmds_pll.io.STDBY := False
    tmds_pll.io.RST := False
    tmds_pll.io.ENCLKOP := True
    tmds_pll.io.ENCLKOS := False
    tmds_pll.io.ENCLKOS2 := False
    tmds_pll.io.ENCLKOS3 := False
    tmds_pll.io.PLLWAKESYNC := False
    tmds_pll.io.PHASESEL0 := False
    tmds_pll.io.PHASESEL1 := False
    tmds_pll.io.PHASEDIR := False
    tmds_pll.io.PHASESTEP := False
    tmds_pll.io.PHASELOADREG := False
    pixclk_x10 := tmds_pll.io.CLKOP

    val dviClockDomain = ClockDomain(
        clock = pixclk,
        config = ClockDomainConfig(resetKind = BOOT),
        frequency = FixedFrequency(25.0 MHz)
    )

    val tmdsClockDomain = ClockDomain(
        clock = pixclk_x10,
        config = ClockDomainConfig(resetKind = BOOT),
        frequency = FixedFrequency(250.0 MHz)
    )

    val dvi_area = new ClockingArea(dviClockDomain) {

	/* Define RGB regs, HV and DE signals */
        val red = Bits(8 bits)
        val green = Bits(8 bits)
        val blue = Bits(8 bits)
        val hSync = Bool()
        val vSync = Bool()
        val vBlank = Bool()
        val de = Bool()

        /* Generate picture using X and Y counters */

        /* Convenience params */
        val horiz_total_width = horiz_back_porch + horiz_active + horiz_front_porch + horiz_sync
        val vert_total_height = vert_back_porch + vert_active + vert_front_porch + vert_sync

        val CounterX = Reg(UInt(log2Up(horiz_total_width) bits))
        val CounterY = Reg(UInt(log2Up(vert_total_height) bits))


        CounterX := (CounterX === horiz_total_width - 1) ? U(0) | CounterX + 1

        when(CounterX === horiz_total_width - 1) {
            CounterY := ((CounterY === vert_total_height - 1) ? U(0) | CounterY + 1)
        }

        /* Produce HSYNC, VSYNC and DE based on back/front porches */
        hSync := (CounterX >= horiz_back_porch + horiz_active + horiz_front_porch) &&
                 (CounterX < horiz_back_porch + horiz_active + horiz_front_porch + horiz_sync)

        vSync := (CounterY >= vert_back_porch + vert_active + vert_front_porch) &&
                 (CounterY < vert_back_porch + vert_active + vert_front_porch + vert_sync)

        de := (CounterX >= horiz_back_porch && CounterX < horiz_back_porch + horiz_active) &&
              (CounterY >= vert_back_porch && CounterY < vert_back_porch + vert_active)

        when(de) {

            /* Period of visible area - Synthesize picture */ 
            red := CounterY(5 downto 4) ## B"000000" 
            green := CounterX(6 downto 5) ## B"000000" 
            blue := CounterX(7) ## B"0000000"

        } otherwise {
            /* Period of blanking */
            red := 0
            green := 0
            blue := 0
        }


	/* Do TMDS encoding */

	/* Pass each color reg through external TMDS encoder to get TMDS regs filled */

        val encoder_R = TMDS_encoder()
        encoder_R.clk := pixclk
        encoder_R.VD := red
        encoder_R.CD := B"00"
        encoder_R.VDE := de 

        val encoder_G = TMDS_encoder()
        encoder_G.clk := pixclk
        encoder_G.VD := green
        encoder_G.CD := B"00"
        encoder_G.VDE := de 

        val encoder_B = TMDS_encoder()
        encoder_B.clk := pixclk
        encoder_B.VD := blue
        encoder_B.CD := vSync ## hSync /* Blue channel carries HSYNC and VSYNC controls */
        encoder_B.VDE := de 

        /* Produce TMDS clock differential signal which is PIXCLK, i.e. 25.0 MHz, not 250.0 MHz !!! */
        val tmds_clk = OBUFDS()
        tmds_clk.I := pixclk
        io.hdmi.tmds_clk_p := tmds_clk.O
        io.hdmi.tmds_clk_n := tmds_clk.OB

    }

    val tmds_area = new ClockingArea(tmdsClockDomain) {

        /* Generate 25 MHz PIXCLK by dividing pixclk_x10 by 10 */

        val clk_div = Reg(UInt(4 bits)) init(0)
        val clk = Reg(Bool())

        clk_div := clk_div + 1

        when(clk_div === 4) {
            clk := True
        }

        when(clk_div === 9) {
            clk := False
            clk_div := 0
        }

        pixclk_in := clk

	/* Produce G, R and B data bits by shifting each TMDS register.
           Use BufferCC() to cross clock domains.  */
	
        val TMDS_shift_red = Reg(Bits(10 bits)) init(0)
        val TMDS_shift_green = Reg(Bits(10 bits)) init(0)
        val TMDS_shift_blue = Reg(Bits(10 bits)) init(0)
        val TMDS_mod10 = Reg(UInt(4 bits)) init(0)
        val TMDS_shift_load = Reg(Bool()) init(False)

        TMDS_shift_red := TMDS_shift_load ? BufferCC(dvi_area.encoder_R.TMDS) | TMDS_shift_red(9 downto 1).resized
        TMDS_shift_green := TMDS_shift_load ? BufferCC(dvi_area.encoder_G.TMDS) | TMDS_shift_green(9 downto 1).resized
        TMDS_shift_blue := TMDS_shift_load ? BufferCC(dvi_area.encoder_B.TMDS) | TMDS_shift_blue(9 downto 1).resized
        TMDS_mod10 := ((TMDS_mod10 === U(9)) ? U(0) | TMDS_mod10 + 1)
        TMDS_shift_load := TMDS_mod10 === U(9)

	/* Produce differential signals using hard OBUFDS block */

        val tmds_0 = OBUFDS()
        tmds_0.I := TMDS_shift_blue(0)
        io.hdmi.tmds_p(0) := tmds_0.O
        io.hdmi.tmds_n(0) := tmds_0.OB

        val tmds_1 = OBUFDS()
        tmds_1.I := TMDS_shift_green(0)
        io.hdmi.tmds_p(1) := tmds_1.O
        io.hdmi.tmds_n(1) := tmds_1.OB

        val tmds_2 = OBUFDS()
        tmds_2.I := TMDS_shift_red(0)
        io.hdmi.tmds_p(2) := tmds_2.O
        io.hdmi.tmds_n(2) := tmds_2.OB
    }

}

object KarnixTestHDMIVerilog{
  def main(args: Array[String]) {
    SpinalVerilog(KarnixTestHDMITopLevel().setDefinitionName("KarnixTestHDMITopLevel"))
  }
}

